<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>geobo.sensormodel API documentation</title>
<meta name="description" content="Calcuation of forward models of gravity and magnetic sensitivity as well as drill core transfromation â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geobo.sensormodel</code></h1>
</header>
<section id="section-intro">
<p>Calcuation of forward models of gravity and magnetic sensitivity as well as drill core transfromation.</p>
<p>The forward models transform the localized measurement of a remote sensor grid into a 3D representation
of geophysical properties of a region, here
gravity and magnetic forward models:
The gravity forward model is defined by using Li's tractable approximation for a 3-D field
of constant density prisms ( Li and Oldenbur, 3D-inversion of gravity data, 1998})
and can be determined analytically. The induced magnetic field calculation uses Li's tractable approximation
for a 3-D field of prisms of constant magnetic susceptibility,
which depends on the magnetic mineral content below the surface and is measured
by the response of their magnetic dipoles induced by the Earth's magnetic field.
The joint GP inversion takes into account a covariance that exists between density and magnetic susceptibility.</p>
<p>Author: Sebastian Haan</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Calcuation of forward models of gravity and magnetic sensitivity as well as drill core transfromation.

The forward models transform the localized measurement of a remote sensor grid into a 3D representation 
of geophysical properties of a region, here  gravity and magnetic forward models: 
The gravity forward model is defined by using Li&#39;s tractable approximation for a 3-D field 
of constant density prisms ( Li and Oldenbur, 3D-inversion of gravity data, 1998}) 
and can be determined analytically. The induced magnetic field calculation uses Li&#39;s tractable approximation 
for a 3-D field of prisms of constant magnetic susceptibility, 
which depends on the magnetic mineral content below the surface and is measured 
by the response of their magnetic dipoles induced by the Earth&#39;s magnetic field. 
The joint GP inversion takes into account a covariance that exists between density and magnetic susceptibility.

Author: Sebastian Haan
&#34;&#34;&#34;

import numpy as np
from config_loader import *



def A_sens(magneticField, locations, Edges, func):
        &#34;&#34;&#34;
        calculate gravity and magnetic forward model matrix

        PARAMETER

        :param magneicField: ambient magnetic field
        :param func: &#39;grav&#39; for gravity, &#39;magn&#39; for magnetic

        RETURNS

        Forward model
        eZ
        &#34;&#34;&#34;
        Edges = np.asarray(Edges)
        xEdges = Edges[0]
        yEdges = Edges[1]
        zEdges = Edges[2]
        bx = magneticField[0]
        by = magneticField[1]
        bz = magneticField[2]
        nprism = xNcube* yNcube * zNcube
        nedge = (xNcube+1)* (yNcube+1) * (zNcube+1)
        sens = np.zeros((1 * xNcube * yNcube, nprism))
        result_ez = np.zeros((1 * xNcube * yNcube, nedge))

        # For each sensor location
        for n in range(1 * xNcube * yNcube):
                x0 = xEdges - locations[n, 0]
                y0 = yEdges - locations[n, 1]
                z0 = zEdges - locations[n, 2] # z-axis already inverted

                # Lazy edge padding for both grav and mag
                aLongWay = 1e6 # Metres, chosen as in Obsedian
                x0[0] -= aLongWay
                y0[0] -= aLongWay
                x0[-1] += aLongWay
                y0[-1] += aLongWay

                #Precompute eZ for each point
                if func == &#39;grav&#39;:
                        eZ = grav_func(x0, y0, z0) # shape (Ncube+1,Ncube+1,Ncube+1)
                elif func == &#39;magn&#39;:
                        eZ = magn_func(x0, y0, z0, bx, by, bz)
                else:
                        print(&#39;function not supported&#39;)
                result_ez[n,:] = eZ.reshape((xNcube+1)*(yNcube+1)*(zNcube+1))

                # Compute the sensitivities     
                idx = 0
                for i in range(xEdges.shape[0]-1):
                    for j in range(yEdges.shape[1]-1):
                        for k in range(zEdges.shape[2]-1):
                                sens[n, idx] = -((eZ[i + 1, j + 1, k + 1] - eZ[i + 1, j + 1, k] - eZ[i + 1, j, k + 1] + eZ[i + 1, j, k]) 
                                        - (eZ[i, j + 1, k + 1] - eZ[i, j + 1, k] - eZ[i, j, k + 1] + eZ[i, j, k]))
                                idx += 1

        if func == &#39;grav&#39;:
                sens = c_MILLIGALS_UNITS * sens / fcor_grav
        if func == &#39;magn&#39;:
                sens = sens / fcor_mag

        return sens, result_ez


def grav_func(x, y, z):
        &#34;&#34;&#34;
        Compute the vertical component of gravity
        Computes the sensitivity for a particular point in the gravity

        PARAMETER

        :param x: x coordinate of the position.
    :param y: y coordinate of the position.
    :param z: z coordinate of the position.
        &#34;&#34;&#34;
        eps = 1e-9 
        r = np.sqrt(x**2 + y**2 + z**2)
        func =  x * np.log(y + r) + y * np.log(x + r) - z * np.arctan((x * y) / (z * r + eps))
        return func


def magn_func(x,y,z,bx,by,bz):
        &#34;&#34;&#34;
        Compute magnetic forward model
        Calculating the magnetic sensitivity at a particular position relative to the origin.

        PARAMETER

    :param x: x coordinate of the position.
    :param y: y coordinate of the position.
    :param z: z coordinate of the position.
    :param bx: The magnetic field in x-direction at this position
    :param by: The magnetic field in y-direction at this position
    :param bz: The magnetic field in z-direction at this position
        &#34;&#34;&#34;
        r = np.sqrt(x**2 + y**2 + z**2)
        #Compute the normalisation factor for the magnetic field
        normB = np.sqrt(bx * bx + by * by + bz * bz)
        func = 1./ normB * ((2. * by * bz * np.log(x + r)) + (2. * bz * bx * np.log(y + r)) + (2. * by * bx * np.log(z + r))
            + (bz * bz - by * by) * np.arctan((x * z) / (y * r)) + (bz * bz - bx * bx) * np.arctan((y * z) / (x * r))) 
        res = -func
        return res


def A_drill(loc, voxelpos):
        &#34;&#34;&#34;
        Transform the voxel cube into filter matrix for drill hole with sensitivity 1

        PARAMETER
        
        :param loc: x,y,z drillcore coordinates in shape (Ndrillcore, 3)
        :param voxelpos: x,y,z coordinates in shape (3, Nvoxel)
        &#34;&#34;&#34;
        x = voxelpos[0].flatten() #- 1
        y = voxelpos[1].flatten() #- 1
        z = voxelpos[2].flatten() #- 1
        sens = np.zeros((loc.shape[1], xNcube * yNcube * zNcube))
        for i in range(loc.shape[1]):
                coord = loc[:,i]#.astype(int)
                sel = np.where((x == coord[0]) &amp; (y == coord[1]) &amp; (z == coord[2]))
                sens[i, sel] = 1 
        return sens</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geobo.sensormodel.A_drill"><code class="name flex">
<span>def <span class="ident">A_drill</span></span>(<span>loc, voxelpos)</span>
</code></dt>
<dd>
<section class="desc"><p>Transform the voxel cube into filter matrix for drill hole with sensitivity 1</p>
<p>PARAMETER</p>
<p>:param loc: x,y,z drillcore coordinates in shape (Ndrillcore, 3)
:param voxelpos: x,y,z coordinates in shape (3, Nvoxel)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def A_drill(loc, voxelpos):
        &#34;&#34;&#34;
        Transform the voxel cube into filter matrix for drill hole with sensitivity 1

        PARAMETER
        
        :param loc: x,y,z drillcore coordinates in shape (Ndrillcore, 3)
        :param voxelpos: x,y,z coordinates in shape (3, Nvoxel)
        &#34;&#34;&#34;
        x = voxelpos[0].flatten() #- 1
        y = voxelpos[1].flatten() #- 1
        z = voxelpos[2].flatten() #- 1
        sens = np.zeros((loc.shape[1], xNcube * yNcube * zNcube))
        for i in range(loc.shape[1]):
                coord = loc[:,i]#.astype(int)
                sel = np.where((x == coord[0]) &amp; (y == coord[1]) &amp; (z == coord[2]))
                sens[i, sel] = 1 
        return sens</code></pre>
</details>
</dd>
<dt id="geobo.sensormodel.A_sens"><code class="name flex">
<span>def <span class="ident">A_sens</span></span>(<span>magneticField, locations, Edges, func)</span>
</code></dt>
<dd>
<section class="desc"><p>calculate gravity and magnetic forward model matrix</p>
<p>PARAMETER</p>
<p>:param magneicField: ambient magnetic field
:param func: 'grav' for gravity, 'magn' for magnetic</p>
<p>RETURNS</p>
<p>Forward model
eZ</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def A_sens(magneticField, locations, Edges, func):
        &#34;&#34;&#34;
        calculate gravity and magnetic forward model matrix

        PARAMETER

        :param magneicField: ambient magnetic field
        :param func: &#39;grav&#39; for gravity, &#39;magn&#39; for magnetic

        RETURNS

        Forward model
        eZ
        &#34;&#34;&#34;
        Edges = np.asarray(Edges)
        xEdges = Edges[0]
        yEdges = Edges[1]
        zEdges = Edges[2]
        bx = magneticField[0]
        by = magneticField[1]
        bz = magneticField[2]
        nprism = xNcube* yNcube * zNcube
        nedge = (xNcube+1)* (yNcube+1) * (zNcube+1)
        sens = np.zeros((1 * xNcube * yNcube, nprism))
        result_ez = np.zeros((1 * xNcube * yNcube, nedge))

        # For each sensor location
        for n in range(1 * xNcube * yNcube):
                x0 = xEdges - locations[n, 0]
                y0 = yEdges - locations[n, 1]
                z0 = zEdges - locations[n, 2] # z-axis already inverted

                # Lazy edge padding for both grav and mag
                aLongWay = 1e6 # Metres, chosen as in Obsedian
                x0[0] -= aLongWay
                y0[0] -= aLongWay
                x0[-1] += aLongWay
                y0[-1] += aLongWay

                #Precompute eZ for each point
                if func == &#39;grav&#39;:
                        eZ = grav_func(x0, y0, z0) # shape (Ncube+1,Ncube+1,Ncube+1)
                elif func == &#39;magn&#39;:
                        eZ = magn_func(x0, y0, z0, bx, by, bz)
                else:
                        print(&#39;function not supported&#39;)
                result_ez[n,:] = eZ.reshape((xNcube+1)*(yNcube+1)*(zNcube+1))

                # Compute the sensitivities     
                idx = 0
                for i in range(xEdges.shape[0]-1):
                    for j in range(yEdges.shape[1]-1):
                        for k in range(zEdges.shape[2]-1):
                                sens[n, idx] = -((eZ[i + 1, j + 1, k + 1] - eZ[i + 1, j + 1, k] - eZ[i + 1, j, k + 1] + eZ[i + 1, j, k]) 
                                        - (eZ[i, j + 1, k + 1] - eZ[i, j + 1, k] - eZ[i, j, k + 1] + eZ[i, j, k]))
                                idx += 1

        if func == &#39;grav&#39;:
                sens = c_MILLIGALS_UNITS * sens / fcor_grav
        if func == &#39;magn&#39;:
                sens = sens / fcor_mag

        return sens, result_ez</code></pre>
</details>
</dd>
<dt id="geobo.sensormodel.grav_func"><code class="name flex">
<span>def <span class="ident">grav_func</span></span>(<span>x, y, z)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the vertical component of gravity
Computes the sensitivity for a particular point in the gravity</p>
<pre><code>PARAMETER

:param x: x coordinate of the position.
</code></pre>
<p>:param y: y coordinate of the position.
:param z: z coordinate of the position.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def grav_func(x, y, z):
        &#34;&#34;&#34;
        Compute the vertical component of gravity
        Computes the sensitivity for a particular point in the gravity

        PARAMETER

        :param x: x coordinate of the position.
    :param y: y coordinate of the position.
    :param z: z coordinate of the position.
        &#34;&#34;&#34;
        eps = 1e-9 
        r = np.sqrt(x**2 + y**2 + z**2)
        func =  x * np.log(y + r) + y * np.log(x + r) - z * np.arctan((x * y) / (z * r + eps))
        return func</code></pre>
</details>
</dd>
<dt id="geobo.sensormodel.magn_func"><code class="name flex">
<span>def <span class="ident">magn_func</span></span>(<span>x, y, z, bx, by, bz)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute magnetic forward model
Calculating the magnetic sensitivity at a particular position relative to the origin.</p>
<pre><code>PARAMETER
</code></pre>
<p>:param x: x coordinate of the position.
:param y: y coordinate of the position.
:param z: z coordinate of the position.
:param bx: The magnetic field in x-direction at this position
:param by: The magnetic field in y-direction at this position
:param bz: The magnetic field in z-direction at this position</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def magn_func(x,y,z,bx,by,bz):
        &#34;&#34;&#34;
        Compute magnetic forward model
        Calculating the magnetic sensitivity at a particular position relative to the origin.

        PARAMETER

    :param x: x coordinate of the position.
    :param y: y coordinate of the position.
    :param z: z coordinate of the position.
    :param bx: The magnetic field in x-direction at this position
    :param by: The magnetic field in y-direction at this position
    :param bz: The magnetic field in z-direction at this position
        &#34;&#34;&#34;
        r = np.sqrt(x**2 + y**2 + z**2)
        #Compute the normalisation factor for the magnetic field
        normB = np.sqrt(bx * bx + by * by + bz * bz)
        func = 1./ normB * ((2. * by * bz * np.log(x + r)) + (2. * bz * bx * np.log(y + r)) + (2. * by * bx * np.log(z + r))
            + (bz * bz - by * by) * np.arctan((x * z) / (y * r)) + (bz * bz - bx * bx) * np.arctan((y * z) / (x * r))) 
        res = -func
        return res</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geobo" href="index.html">geobo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geobo.sensormodel.A_drill" href="#geobo.sensormodel.A_drill">A_drill</a></code></li>
<li><code><a title="geobo.sensormodel.A_sens" href="#geobo.sensormodel.A_sens">A_sens</a></code></li>
<li><code><a title="geobo.sensormodel.grav_func" href="#geobo.sensormodel.grav_func">grav_func</a></code></li>
<li><code><a title="geobo.sensormodel.magn_func" href="#geobo.sensormodel.magn_func">magn_func</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>